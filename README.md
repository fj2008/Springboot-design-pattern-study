# v2 예제 코드
- 문제점
1. 제사용성이 굉장히 떨어진다.
2. service부터 호출하거나 하면 로그의 깊이를 표현할 방법이 사라진다.
3. 단순히 문제 해결에만 집중한 코드이다.

## 필드 동기화
위문제를 해결하기위해서 향후 다양한 구현제로 변경할 수 있도록 logTrace인터페이스를 먼저 만들고 구현해본다.
그리고 파라미터를 넘기지 않고 동기화 할 수 있도록 fieldLogTrace구현체 만든후 
@configration에 bean등록을 해서 ioc에 등록해서 외부에서 사용할 수 있도록 한다.

- 필드 동기화로 잘 만들어 졌기때문에 이를 배포한다고 했을때 생길 수 있는 문제중 가장 큰 문제는 동시성 문제이다.

## 필드 동기화 -> 동시성 문제
fieldLogTrace는 심각한 동시성 문제가 있다.
동시성 문제?
- 첫호출작업이 끝나기도 전에 동시에 다발적으로 호출하게되면 로그가 분리되지않고 떡져서 출력된다.
  2022-03-18 14:01:50.203  INFO 8125 --- [nio-8080-exec-1] c.s.s.trace.logtrace.FieldLogTrace       : [461a9d0f] |-->OrderService.orderItem()
- 위 로그는 일반적으로 스프링에서 볼 수 있는 로그인데
- [nio-8080-exec-1] 이 부분은 톰켓에 와스가 알려주는 스래드이름이다. 해당 스택을 실행하는 쓰래드 이름.
- 이와같이 되는 이유는 fieldLogTrace가 싱글톤으로 빈에 등록 돼있기 때문이다. 객체의 인스턴스가 jvm에 하나만 있기때문에 
여러쓰래드가 하나의 인스턴스에 여기에 몰려있는것때문에 이런 문제가 생기는 것이다.

## 동시성 문제 해결 하기 ThreadLocal 
스레드 로컬은 해당 스레드만 접근할 수 있는 특별한 저장소를 말한다. 물건 보관 창구 같ㅣ 여러사람이 같은 물건 보관 창구를 사용하더라도
창구직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해 준다.

- 일반적인 변수 필드
여러 쓰레드가 같은 인스턴스필드에 접근하면 처음쓰레드가 보관한 데이터가 사라질 수 있다.먼저 작업한 스레드가 후에 들어온 스레드가 값을 덮어씌우거나 하는경우.
- 쓰래드 로컬
스레드 로컬을 사용하면 각 스레드마다 별도의 내부 저장소를 제공한다. 따라서 같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제가 없다.
스레드 로컬을 통해서 데이터를 조회할때도 스레드로컬 전용 보관소에서 구분해서 데이터를 문제해준다. java는 java.lang.ThreadLocal을 지원한다.
#### 사용법
ex )
```

 private ThreadLocal<String> 변수 = new ThreadLocal<>();
 변수.get() //값을 가져올때
 변수.set() //값을 저장할때
 
```
**주의 사항**
- 해당 스레드가 스레드 로컬을 모두 사용하고 나면 ThreadLocal.remove()를 호출해서 스레드로컬을 제거해 줘야한다.
제거해 주지 않은면 서비스를 했다는 가정하에
- 사용자 a의 요청이 끝나고 스레드로컬이 살아있다. 그럼 사용자 b가 요청을 했을때 사용자a가 사용했던 스레드 로컬이 배정되면
사용자b는 사용자 a값이 조회가 되기때문에 심각한 문제가 생길 수 있다.

# 템플릿 메서드 패턴
해당 로그 적기를 도입하기엔 핵심로직외에 들어가야 하는 코드가 너무 많다.
부가 기능과 관련된 코드는 중복이기때문에 뽑아 내면 되는데 이때 try~catch도 있고 여러한 경우의 수때문에 메서드로 뽑아 내기가 힘들다.
템플릿 메서드 패턴이 이문제를 해결해 준다.

템플릿 메서드의 구조는 추상클레스 안에 변하지 않는 로직들을을 다 넣어놓고 변하는 로직은 별도로 호출해서 해결하는패턴입니다

```
public abstract class 추상클레스{

public void ex(){
부가기능코드~~

핵심로직코드() //호출

부가기능코드~~

}

protected abstract void 핵심로직코드();

}
```
위 추상클래스를 상속받아서 핵심로직코드()를 오버라이딩하면 된다.

이렇게 할 수 있는 이유는 자식클래스에 오버라이딩을 하면 오버라이딩된 함수가 실행되기 때문입니다.
하지만 이 방법의 단점은 클래스를 계속 만들어야 하는 단점이 있다.

### 익명내부 클래스 활용하기
익명 내부 클래스를 사용하면 객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속 받은 자식 클래스를 정의할 수 있다.

## 정리
부모클래스에 알고리즘의 골격인 템플릿을 정의하고 일부 변경되는 로직은 자식클래스에 정의하는 것이다. 이렇게 하면 자식클래스가 알고리즘의 전체구조를 변경하지 않고 특정부분만 재정의 할수 있다
**단점!**
자식클래스가 부모클래스와 컴파일 시점에 강하게 결합되는 단점이 있다.
자식클래스입장에서 부모클래스의 기능을 사용하지 않는데 부모클래스의 무거운 탬플릿 로직을 다 들고있는것이다. 그래서 부모클래스를 강하게의존하게 된다.
즉 부모클래스에 무슨일이 생기면 모든 자식클래스들에 영향을 받기때문에 단점이 명확하다.
**이러한 단점을 제거하는 디자인 패턴이 전략패턴이다.**

# 전략패턴
전략패턴은 변하지 않는 부분을 Context라는 곳에 두고 변하는 부분을 Strategy라는 인터페이스를 만들고 해당 인터페이스를 구현하도록해서 문제를 해결한다.
상속이 아니라 위임으로 문제를 해결하는 것이다.
전략패턴에서 context는 변하지 않는 탬플릿역할을 하고 Strategy는 변하는 알고리즘 역할을 한다.
알고리즘 제품군을 정의하고 각각 캡슐화 하여 상호 교환 가능하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 변경할 수 있다.

전략패턴의 핵심은 strategy의 인터페이스에만 의존한다는 점이다.
덕분에 Strategy의 구현체를 변경하거나 새로 만들어도 기존 Context코드에는 영향을 주지않는다
- 스프링에서 DI를 하는 의존관계주입에서 사용하는 방식이 바로 전략패턴이다.

### 선 조립 후 실행 방식
전략 패턴은 실행전에 원하는 모양으로 조립을 해두고 그다음에 실행하는 선조립 후 방식이다.

한번 조립을 하고 나면 이후로는 실행하기만 하면 된다. 스프링으로 애플리케이션을 개발할때 애플리케이션 로딩 시점에 의존관계 주입을 통해 필요한 의존관계를 모두 맺어두고 난 다음에실제 요청을 처리하는 것과 같은 원리입니다.

이 방식의 단점은 조립한 이후에는 전략을 변경하기가 번거롭다는 점이다.
좀 더 유연하게 하기 위해서는 전략을 실행할때 직접 파라미터로 전달해서 사용하는 방법이있다.